\pagebreak
\begin{frame}{Gegenmaßnahmen}{Übersicht}
    Low-Level:
\begin{itemize}
    \item Hardware-basierte Lösungen
    \item Betriebssystembasierte Ansätze
\end{itemize}
Passive Härtung der Programme:
\begin{itemize}
    \item C Range Error Detector und Out Of Bounds Object
    \item Address Space Layout Randomization
    %\item Safe Pointer Instrumentalisierung wäre zu viel https://download.vusec.net/papers/delta-pointers_eurosys18.pdf
    \item Manuelles Buffer-Overflow-Blocken (Input-Bereinigung)
\end{itemize}
Aktive (analysierende) Lösungen:
\begin{itemize}
    \item Statische Analyse
    \item Stack-Schutz mit ``Canary'' (Zufallszahl)
\end{itemize}
\end{frame}



\begin{frame}{Gegenmaßnahmen}{Low-Level-Probleme}
    Hardware- und betriebssystembasierte Lösungen
   \begin{itemize}
       \item können alle Overflows verhindern
       \item können nicht unterscheiden ob böswillig oder geplant
   \end{itemize}
    
    Leider ist es praktisch nicht umsetzbar, in einer Hardwarelösung
    zu unterscheiden, welcher Buffer Overflow böswillig und welcher gewollt ist. 
    Damit ist dieser Ansatz nicht praktikabel.
\end{frame}

\begin{frame}{Gegenmaßnahmen}{C Range Error Detector und Out Of Bounds Object}
    Out Of Bounds Object versucht Referenzen ungefährlich zu machen.\\
    Jede
    Adresse, welche nicht im gültigen Bereich liegt, verweist auf das OOBO. \\
    Kann umgangen werden, sofern der Angreifer über Speicheradressen informiert ist. %die Adressen des Programms
\end{frame}




\begin{frame}{Gegenmaßnahmen}{Testen}
    \begin{itemize}
        \item erhöhen Sicherheit und Robustheit. 
        \item Werkzeuge wie SonarLint% können häufig auftretende Fehler entdeckt werden.
        \item Fuzzy Tests -- gezielt zufällig
        \item spezifische Payloads und Escape-Sequenzen
    \end{itemize}    
\end{frame}


\begin{frame}{Gegenmaßnahmen}{Statische Analyse}
    Programm wird bereits vor der Ausführung analysiert 
    Ein Tool kann Schwachstellen bestimmen und
    vorschlagen, wie diese behoben werden könnten.
    
    Zeitsparend aber alleine nicht ausreichend.
    
    Abwesenheit von Schwachstellen unmöglich zu bestimmen.
\end{frame}


\begin{frame}{Gegenmaßnahmen}{Bug-Bounty-Programme} 
    Externalisieren von Tests durch Prämien für gefundene Sicherheitslücken.
    Die Prämien sind meist davon abhängig, in welcher Version der Software der Angriff 
    wirksam ist und welche Voraussetzungen erfüllt sein müssen (physikalischer Zugriff / Netzwerkverbindung),
    um den Angriff auszuführen. Auch wichtig für die Höhe der Prämie ist, welche Art des Zugriffes
    der Angriff ermöglicht.
    
    Wurde ein Buffer Overflow entdeckt, so wird meist die höchste Prämienstufe ausgezahlt, da bei einem
    Buffer Overflow mit der passenden Payload ein Shellcode ausgeführt werden kann, welcher dann das
    höchste Ziel bei einem Angriff - eine Root Shell - erreicht.
    Diese hohe Zugriffsstufe macht einen Buffer-Overflow-Angriff immer zu einem der attraktivsten Vektoren. 
    Sind mehrere Schwachstellen für ein Programm bekannt, ist dessen Version meist veraltet. 
    
    
\end{frame}


\begin{frame}{Gegenmaßnahmen}{Stack-Schutz mit Canaries} 
    Die Bezeichnung Canary (engl. Kanarienvogel) leitet sich ab aus der Verwendung von Kanarienvögel als
    Indikator für Gas in Minen. Die Canaries im Code werden als Stack-Schutz verwendet. Das bedeutet,
    
    Compiler haben ein Pendant zu ASLR welches pie
    genannt wird. So müssen also beim GCC zum Kompilieren die Flags \codeline{gcc -fPIE -pie}
    gesetzt werden. Dies führt dann dazu, dass das kompilierte Programm auch tatsächlich an
    unabhängigen und von Ausführung zu Ausführung unterschiedlichen Speicheradressen lauffähig
    ist.
    Nach dem gleichen Konzept ist es dann einem Angreifer nicht ohne weiteres möglich, die
    Speicheradressen der Komponenten eines Programms zu kennen, da diese abhängig
    von der (nun zufälligen) Speicheradresse des Programms sind. Kombiniert man nun beide Lösungen,
    so sind nun alle Adressen zufällig und nicht voneinander abhängig.
    
    
\end{frame}


\begin{frame}{Gegenmaßnahmen}{Manuelles Buffer-Overflow-Blocken}
    Ein Programmierer kann Buffer Overflows verhindern, indem er die Eingaben,
    welche er entgegennimmt, zuerst filtert und dann validiert. Leider funktioniert
    dies nicht immer zuverlässig und ist für einige Angriffsvektoren schlichtweg nicht
    möglich, da oft nicht zwischen normaler und böswilliger Anfrage unterschieden werden kann. 
    Es ist aber dennoch hilfreich, die sogenannte Input Sanitization einzubauen.
    Input Sanitization befasst sich grundlegend damit, infizierte Eingaben zu bereinigen, 
    sodass im schlimmsten Fall eine semantisch inkorrekte Eingabe weiterverarbeitet
    wird, nicht aber Datenlecks oder ungewollte Aufrufe entstehen. \\
    Dadurch ist dieser Ansatz sehr effektiv, aber dafür auch sehr aufwändig.
    
    
\end{frame}

